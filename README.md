mx.tools
========
Плагин пока еще находится в разработке, использовать на свой страх и риск!

Данный модуль предоставляет средства для упрощения разработки сайтов на основе 1С Битрикс, и обладает следующим функционалом:

 - Автозагрузчик классов (psr-4) 
 - Автозагрузчик обработчиков событий
 - Базовый класс для обработчиков событий

Для начала использования модуля нужно произвести его установку через административную панель, после чего подключить модуль в init.php:

  ```php
    <?php
    Bitrix\Main\Loader::includeModule('mx.tools');
  ```
    
1. Автозагрузчик классов.
Работает на основе стандарта автозагрузки [PSR-4](http://www.php-fig.org/psr/psr-4/ru/) и представлен классом \Mx\Tools\Psr4Loader. Для регистрации своих классов нужно создать инстанс класса, добавить соответствия путей и пространств имен, зарегистрировать автозагрузчик, например, в том же init.php

  ```php
    <?php
    $psr4 = \Mx\Tools\Psr4Autoloader::getInstance();
    $psr4->addNamespace('Mx', __DIR__  . '/../classes/Mx');
    $psr4->register();
  ```
  После этого все классы из classes/Mx/ будут подгружаться автоматически при соблюдении правил именования классов.

2. Автозагрузчик обработчиков событий. Представлен классом \Mx\Tools\Events\Listener, построен на основе psr-4 автозагрузчика (предоставляет тот же интерфейс регистрации). В понятии данного класса каждый обработчик события - это метод определенного класса. Класс должен именоваться в соответствии со строковым идентификатором события, имя метода-обработчика значения не имеет. Каждый класс обработчик должен принадлежать пространству имен, которое имеет имя модуля, которому этот обработчик принадлежит. Например, если нужно зарегистрировать обработчик события OnPageStart, то необходимо создать класс, полное имя которого будет кончаться на Main\OnPageStart и создать в этом классе метод с любым именем. Для регистрации директории с обработчиками событий нужно написать примерно следующее

  ```php
    <?php
    $eventListener = new \Mx\Tools\Events\Listener();
    $eventListener->addNamespace('Mx\\Main\\EventHandler', __DIR__ . '/../classes/Mx/Main/EventHandler');
    $eventListener->register();
  ```
  
3. Базовый класс для обработчиков событий. 
Данный класс предоставляет обработчикам событий расширенные возможности. Для использования этих возможностей нужно класс обработчика события унаследовать от данного класса. Например, при создании класса OnPageStart нужно указать, что он будет унаследован от \Mx\Tools\Events\Base

  ```php
    <?php
    class OnPageStart extends \Mx\Tools\Events\Base {}
  ```
    Данный класс предоставляет следующие возможности:
 - Обмен данными между обработчиками событий. Для этого нужно воспользоваться методами setData($key, $value) и getData($key). Особенно это полезно, когда нужно контролировать процесс выполнения какого-то события, сначала до выполнения какого-то действия (например удаления), а потом после. Так можно в обработчике OnEndBufferContent получить информацию обо всех удаленных элементах инфоблока в процессе выполнения скрипта.
 - Управление порядком вызова обработчиков. Чтобы изменить порядок вызова, нужно в классе обработчика переопределить статическую переменную $sort. Она должна хранить в себе массив, где в качестве ключа выступает имя метода, а в качестве значения - порядок сортировки. В стандартных обработчиках событий порядок сортировки, как правило равен 100, поэтому с помощью данного механизма можно вызвать свой обработчик события до битриксового.

4.  Расширение для Orm.
Данный класс предоставляет возможность выполнять выборку данных из инфоблоков вместе со свойствами. Пока поддерживаются только единичные свойства. Значения свойств выбираются "как есть", модификация данных к ним не применяется.
Для составления запросов к одиночным инфоблокам, нужно создать свою сущность, которая будет описывать инфоблок. Для этого нужно создать класс, который будет являться наследником класса Mx\Tools\Orm\Iblock\ElementTable. Этот класс должен реализовывать лишь один метод, который должен вернуть идентификатор инфоблока:

  ```php
    <?php
    namespace Mx\Main;

	use Mx\Tools\Orm\Iblock\ElementTable;
	
	class ProductTable extends ElementTable
	{
	    public static function getIblockId()
	    {
	        return 1;
	    }
	}
	
  ```

Теперь можно пользоваться данным классом для обращения к инфоблоку с идентификатором 1. Устанавливать фильтр по инфоблоку в этом случае не нужно, при запросе фильтр будет автоматически добавлен. Фильтры со сложной логикой и с модификаторами не отслеживаются, поэтому отслеживать задание фильтров по другим инфоблокам нужно самостоятельно.
Для получения значения свойства нужно использовать имя поля 'PROPERTY_CODE_VALUE', где CODE - это символьный код свойства. Для получения описания значения свойства, нужно использовать имя поля 'PROPERTY_CODE_DESCRPTION'. Сама сущность свойства хранится в поле 'PROPERTY_CODE'. В зависимости от типа хранения свойства, можно обратиться к таблице через эту сущность. Например, получить ID значения свойства можно через поле 'PROPERTY_CODE.ID'.

Для составления запроса к нескольким инфоблокам сразу, не нужно использовать наследника класса Mx\Tools\Orm\Iblock\ElementTable, а напротив, использовать этот класс самостоятельно. Все свойства всех используемых в фильтре инфоблоков будут подцеплены к запросу автоматически и будут подцепляться к нему на каждом запросе, поэтому будьте внимательны и следите за производительностью. Составление каждого такого запроса может занимать достаточно длительное время (сотые доли секунды).
